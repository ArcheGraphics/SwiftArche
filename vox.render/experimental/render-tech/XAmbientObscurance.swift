//  Copyright (c) 2023 Feng Yang
//
//  I am making my contributions/submissions to this project solely in my
//  personal capacity and am not conveying any rights to any intellectual
//  property of any third parties.

import Math

// Encapsulates the pipeline states and intermediate objects required for
//  Scalable Ambient Obscurance.
class XAmbientObscurance {
    // Device from initialization.
    private var _device: MTLDevice
    // Pipeline state for generating the SAO texture.
    private var _scalableAmbientObscurancePipeline: MTLComputePipelineState
    // The underlying SAO texture.
    private var _texture: MTLTexture!

    // The SAO texture generated by the update.
    var texture: MTLTexture {
        _texture
    }

    // Initializes this object, allocating metal objects from the device based on
    //  functions in the library.
    init(with device: MTLDevice, library: MTLLibrary) {
        _device = device
        _scalableAmbientObscurancePipeline = newComputePipelineState(library: library, functionName: "scalableAmbientObscurance",
                                                                     label: "ScalableAmbientObscurance", functionConstants: nil)!
    }

    // Writes commands to update the SAO texture using the command buffer, with
    // AAPLFrameConstants from the frameDataBuffer with the latest depth data.
    func update(_ commandBuffer: MTLCommandBuffer,
                frameDataBuffer: MTLBuffer,
                cameraParamsBuffer: MTLBuffer,
                depth: MTLTexture,
                depthPyramid: MTLTexture)
    {
        if let computeEncoder = commandBuffer.makeComputeCommandEncoder() {
            computeEncoder.label = "SAO Generation"
            computeEncoder.setComputePipelineState(_scalableAmbientObscurancePipeline)
            computeEncoder.setBuffer(frameDataBuffer, offset: 0, index: Int(XBufferIndexFrameData.rawValue))
            computeEncoder.setBuffer(cameraParamsBuffer, offset: 0, index: Int(XBufferIndexCameraParams.rawValue))
            computeEncoder.setTexture(_texture, index: 0)
            computeEncoder.setTexture(depth, index: 1)
            computeEncoder.setTexture(depthPyramid, index: 2)
            computeEncoder.dispatchThreads(MTLSizeMake(_texture.width, _texture.height, 1),
                                           threadsPerThreadgroup: MTLSizeMake(8, 8, 1))
            computeEncoder.endEncoding()
        }
    }

    // Resizes the internal data structures to the required output size.
    func resize(_ size: CGSize) {
        let validSAOTexture = _texture != nil &&
            _texture!.width == Int(size.width) &&
            _texture!.height == Int(size.height)
        if !validSAOTexture {
            let saoTexDesc = MTLTextureDescriptor.texture2DDescriptor(pixelFormat: .r8Unorm, width: Int(size.width),
                                                                      height: Int(size.height), mipmapped: false)
            saoTexDesc.storageMode = .private
            saoTexDesc.usage = [.shaderWrite, .shaderRead]

            _texture = _device.makeTexture(descriptor: saoTexDesc)
            _texture.label = "SAOTexture"
        }
    }
}
